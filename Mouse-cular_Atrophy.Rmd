---
title: "Mouse-scular Atrophy"
author: "Hugues Escoffier"
date: "2023-01-17"
output:
  pdf_document: default
  html_document: default
---

TODO: Find a way to directly attribute cluster to a type of cell based on literature data. (`Python` ?) 
      Parallelization : https://satijalab.org/seurat/articles/future_vignette.html
      R Version 4.1.0 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Install libraries 
library(Seurat)
library(Signac) 
library(clustree)
# Additional 
library(patchwork)
library(dplyr)
library(ggplot2)
library(here)
library(MASS)
library(future)
# Genome 
library(EnsDb.Mmusculus.v79) # Issue Related to R version  
```

# Functions

```{r}
# 
plot_trimming <- function(x) {
  # Plots 
  VnPlot <- VlnPlot(x, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
  RNAcount_MTPer <- FeatureScatter(x, feature1 = "nCount_RNA", feature2 = "percent.mt")
  RNAcount_RNAFeat <- FeatureScatter(x, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
  # Visualise 
  print(VnPlot)
  print(RNAcount_MTPer + RNAcount_RNAFeat)
}

# Analyse of a single dataset 
# Normalisation, scaling, PCA & Dim 
first_automatisation <- function(input_data){
  # Visualization before trimming
  print(plot_trimming(input_data))
  # Trimming 
  input_data <- subset(input_data, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 0.8)
  # Visualization after trimming 
  plot_trimming(input_data)
  # Normalisation with SCTransfrom
  # input_data <- SCTransform(input_data, vst.flavor = "v2", verbose = FALSE, vars.to.regress = "percent.mt")
  # Normalisation with LogNormalize 
  input_data <- NormalizeData(input_data, normalization.method = "LogNormalize", scale.factor = 10000)
  # Scaling
  input_data <- FindVariableFeatures(input_data, selection.method = "vst", nfeatures = 2000)
  all.genes <- rownames(input_data)
  input_data <- ScaleData(input_data, features = all.genes)
  # PCA + Plot
  input_data <- RunPCA(input_data, npcs=50, features = VariableFeatures(object = input_data), verbose = FALSE)
  print(DimPlot(input_data, reduction = "pca"))
  # Elbow Plot 
  print(ElbowPlot(input_data, ndims = 50))
  return(input_data)
}

# Cluster, UMAP, Markers & Heatmap 
second_automatisation_clustree <- function(input_data, dimensionality) {
  # Clustering
  input_data <- FindNeighbors(input_data, reduction = "pca", dims = 1:dimensionality, verbose = FALSE)
  resolution.range <- seq(from = 0, to = 1, by = 0.2)
  input_data <- FindClusters(object = input_data, resolution = resolution.range)
  input_data <- RunUMAP(input_data, dims = 1:dimensionality)
  DefaultAssay(input_data) <- 'RNA'
  #Plot
  print(DimPlot(input_data, reduction = "umap", label = TRUE))
  input_data.markers <- FindAllMarkers(input_data, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE) # Verify the treshord 
  print(head(input_data@meta.data))
  print(clustree(input_data, prefix = 'RNA_snn_res.'))
  return(input_data)
}

second_automatisation_simple <- function(input_data, dimensionality, choose.resolution) { 
  # Clustering
  input_data <- FindNeighbors(input_data, reduction = "pca", dims = 1:dimensionality, verbose = FALSE)
  input_data <- FindClusters(object = input_data, resolution = choose.resolution)
  input_data <- RunUMAP(input_data, dims = 1:dimensionality)
  DefaultAssay(input_data) <- 'RNA'
  #Plot
  print(DimPlot(input_data, reduction = "umap", label = TRUE))
  input_data.markers <- FindAllMarkers(input_data, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE) # Verify the treshold 
  return(input_data)
}

# WNN Analysis
wnn_analysis <- function(input_multi.data){
  # Trimming 
  input_multi.data <- subset(x = input_multi.data, 
                             subset = nCount_ATAC < 7e4 & nCount_ATAC > 5e3 & nCount_RNA < 25000 & nCount_RNA > 1000 & percent.mt < 20)
  # Normalization 
  DefaultAssay(input_multi.data) <- "RNA"
  input_multi.data <- SCTransform(input_multi.data, verbose = FALSE) %>% RunPCA() %>% RunUMAP(dims = 1:50, reduction.name = 'umap.rna', reduction.key = 'rnaUMAP_')
  # UMAP 
  DefaultAssay(input_multi.data) <- "ATAC"
  input_multi.data <- RunTFIDF(input_multi.data)
  input_multi.data <- FindTopFeatures(input_multi.data, min.cutoff = 'q0')
  input_multi.data <- RunSVD(input_multi.data)
  input_multi.data <- RunUMAP(input_multi.data, reduction = 'lsi', dims = 2:50, reduction.name = "umap.atac", reduction.key = "atacUMAP_")
  # Find Clusters & Neighbors 
  input_multi.data <- FindMultiModalNeighbors(input_multi.data, reduction.list = list("pca", "lsi"), dims.list = list(1:50, 2:50))
  input_multi.data <- RunUMAP(input_multi.data, nn.name = "weighted.nn", reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
  input_multi.data <- FindClusters(input_multi.data, graph.name = "wsnn", algorithm = 3, verbose = FALSE)
  # Visualize 
  umap.snrna <- DimPlot(input_multi.data, reduction = "umap.rna", label = TRUE) + ggtitle("RNA")
  umap.atac <- DimPlot(input_multi.data, reduction = "umap.atac", label = TRUE) + ggtitle("ATAC")
  umap.wnn <- DimPlot(input_multi.data, reduction = "wnn.umap", label = TRUE) + ggtitle("WNN")
  print(umap.snrna)
  print(umap.atac)
  print(umap.wnn)
  return(input_multi.data)
}
```

## Analysis of SnRNA-Seq & ATAC-Seq 

# 1. Data 
In this part we will use Ctl-D data and D (see readme in the 'data' folder for more information) 

```{r}
# Load the data for SnRNA-Seq Analysis
# x correspond to control data, y correspond to D(enervated) data
x.data <- Read10X(data.dir = here("data","Ctl-D", "for_SEURAT", "filtered_feature_bc_matrix"))
y.data <- Read10X(data.dir = here("data","D", "for_SEURAT", "filtered_feature_bc_matrix"))
# Initialize the Seurat object with non-normalized data.
x.rna <- x.data$`Gene Expression`
x.atac <- x.data$Peaks
y.rna <- y.data$`Gene Expression`
y.atac <- y.data$Peaks
# Create a Seurat Object + Add the mitochondrial information
x.rna <- CreateSeuratObject(counts = x.rna, project = "Ctl-D", min.cells = 3, min.features = 200)
x.rna[["percent.mt"]] <- PercentageFeatureSet(x.rna, pattern = "^mt-")
y.rna <- CreateSeuratObject(counts = y.rna, project = "D", min.cells = 3, min.features = 200)
y.rna[["percent.mt"]] <- PercentageFeatureSet(y.rna, pattern = "^mt-")
```

# 2. Merging two dataset 
You can merge two of your datasets. Take the time to change the name of the datasets for a better readability of your results 

```{r}
ctl_d.combined.bis <- merge(x = x.rna, y = y.rna, add.cell.ids = c("CTL", "D"), project = "Ctl_D_Analysis")
# Plot the number of nuclei
# table(ctl_d.combined$orig.ident)
# Split the data into a list 
# ctl_d.list <- SplitObject(object = ctl_d.combined, split.by = "orig.ident")
```

# 3. snRNA-Seq
# Quick Analysis 
This part of the code allows a quick analysis of a snRNA-seq data set loaded in step 1. 

The parameters for trimming are: 
  - 200 > Feature counts > 2,500
  - Mitochondrial counts < 0.8% 
The normalization is done via LogNormalise. 

```{r}
ko.rna <- first_automatisation(y.rna)
ctl.rna <- first_automatisation(x.rna)
```

In the light of the Elbow Plot of the previous part, in this part you have to choose the dimensionality as well as the resolution for the data you are analyzing.
If you need information about the resolution to use, you can use the `second_automatisation_clustree` function which will allow you to obtain the clusturisation trees using the `clustree` library.   

```{r}
ko.rna <- second_automatisation_simple(ko.rna, 15, 0.9)
ctl.rna <- second_automatisation_simple(ctl.rna, 12, 0.9)
```

All theses steps are for a merged dataset.

# 3.1. Trimming 
The filters applied are : 
  - 200 > Feature counts > 2,500
  - Mitochondrial counts < 0.8% 
  
```{r}
for (i in 1:length(x = ctl_d.list)) {
  # Visualization before trimming
  plot_trimming(ctl_d.list[[i]])
  # Trimming 
  ctl_d.list[[i]] <- subset(ctl_d.list[[i]], subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 0.8)
  # Visualization after trimming 
  plot_trimming(ctl_d.list[[i]])
  }
```

# 3.2 Normalisation
Data normalization can be achieved in several ways: 
- NormalizeData: 
  - LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor.
  - CLR: Centered log ratio transformation 
  - RC: Relative counts, feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor.
- SCTransform: 
  _Wip in Progress_ 

SCTransform Installation : https://satijalab.org/seurat/articles/sctransform_v2_vignette.html 

```{r}
# NormalizeData 
for (i in 1:length(x = ctl_d.list)) {
  ctl_d.list[[i]] <- NormalizeData(ctl_d.list[[i]], normalization.method = "LogNormalize", scale.factor = 10000)
  # Calculate a subset of features that exhibit high cell-to-cell variation in the dataset 
  ctl_d.list[[i]] <- FindVariableFeatures(ctl_d.list[[i]], selection.method = "vst", nfeatures = 2000)
  }
```

```{r}
# SCTransform
ctl_d.list <- lapply( X = ctl_d.list, FUN = SCTransform)
features <- SelectIntegrationFeatures(object.list = ctl_d.list, nfeatures = 5000)
ctl_d.list <- PrepSCTIntegration(object.list = ctl_d.list, anchor.features = features)
```

# 3.3 Integration 
_Work in Progress_

```{r}
# Integration with NormaliseData()
ctl_d.combined.anchors <- FindIntegrationAnchors(object.list = ctl_d.list, dims = 1:30)
ctl_d.integrated <- IntegrateData(anchorset = ctl_d.combined.anchors, dims = 1:30)
DefaultAssay(ctl_d.integrated) <- "integrated"
```

```{r}
# Integration with SCTransform()
ctl_d.combined.anchors <- FindIntegrationAnchors(object.list = ctl_d.list, normalization.method = 'SCT', anchor.features = features)
ctl_d.integrated <- IntegrateData(anchorset = ctl_d.combined.anchors, normalization.method = 'SCT')
```

# 3.4 Scaling 
We apply a linear transformation also call ‘scaling’. It is a pre-processing step to dimensional reduction techniques as PCA.

```{r}
all.genes <- rownames(ctl_d.integrated)
ctl_d.integrated <- ScaleData(ctl_d.integrated, features = all.genes)
```

We then perform a PCA on the scaled data. 

```{r}
ctl_d.integrated <- RunPCA(ctl_d.integrated, npcs=50, features = VariableFeatures(object = ctl_d.integrated), verbose = FALSE)
print(ctl_d.integrated[["pca"]], dims = 1:5, nfeatures = 5)
DimPlot(ctl_d.integrated, reduction = "pca")
```

# 3.5 Dimensionality 
The JackStraw procedure help to overcome the technical noise present in scRNA-seq data and identify the number of principal components to include in the analysis. This approach can lead to a robust compression of the dataset and improve the accuracy of the analysis.

Another alternative is to realise an Elbow plot. 

```{r}
# JackStraw Procedure
# ctl_d.integrated <- JackStraw(ctl_d.integrated, num.replicate = 100)
# ctl_d.integrated <- ScoreJackStraw(ctl_d.integrated, dims = 1:20)
# Plot
# JackStrawPlot(ctl_d.integrated, dims = 1:20)
# Elbow Plot
ElbowPlot(ctl_d.integrated, ndims = 50)
```

Interpretation of the result : 

# 3.6 Cluster the cells 
We applies a graph-based clustering approach, building upon initial strategies in Macosko et al. Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. 

We first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the `FindNeighbors()` function, and takes as input the defined dimensionality of the dataset. (cf. 2.4)

The `FindClusters()` function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. The authors of XXX package find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. 


```{r}
# for clustree 
# Input the dimesionality of the dataset find at the 2.4 section 
ctl_d.integrated.data_set.dim = 15

ctl_d.integrated <- FindNeighbors(ctl_d.integrated, reduction = "pca", dims = 1:ctl_d.integrated.data_set.dim, verbose = FALSE)
# Select a range of resolution for Clustree 
resolution.range <- seq(from = 0, to = 1, by = 0.2)
ctl_d.integrated <- FindClusters(object = ctl_d.integrated, resolution = resolution.range)
# ctl_d.integrated <- FindClusters(ctl_d.integrated, resolution = 0.4, verbose = FALSE)
```

```{r}
# for an particular resolution 
# Input the dimesionality of the dataset find at the 2.4 section 
ctl_d.integrated.data_set.dim = 15

ctl_d.integrated <- FindNeighbors(ctl_d.integrated, reduction = "pca", dims = 1:ctl_d.integrated.data_set.dim, verbose = FALSE)
ctl_d.integrated <- FindClusters(ctl_d.integrated, resolution = 0.4, verbose = FALSE)
```

# Facultative Step : Create a subset 
In order to analyse only some part of you data you can create a subset according to some carasteristics. 

Source : 
  - https://satijalab.org/seurat/articles/essential_commands.html 
  - https://github.com/satijalab/seurat/issues/1890 

```{r}
# TODO: Find the values for each genes 
Idents(x.rna, WhichCells(object = x.rna, expression = Myh1 > 2 , slot = 'data')) <- 'Myh1'
Idents(x.rna, WhichCells(object = x.rna, expression = Myh2 > 3, slot = 'data')) <- 'Myh2'
genes <- FindMarkers(x.rna, ident.1 = 'Myh1', ident.2 = 'Myh2' )
print(genes)
```

# 3.7 Non-linear Dimensional Reduction 
_Wip in Progress_ 

```{r}
# 
ctl_d.integrated <- RunUMAP(ctl_d.integrated, dims = 1:ctl_d.integrated.data_set.dim, verbose = FALSE)  # ,umap.method = 'umap-learn', metric = "correlation"
# DefaultAssay(ctl_d.integrated) <- 'RNA' # This line is problematic for the creation of the HeatMAP 
#Plot
DimPlot(ctl_d.integrated, reduction = "umap")
DimPlot(object = ctl_d.integrated, reduction = "umap", group.by = "orig.ident", label = FALSE)
DimPlot(ctl_d.integrated, reduction = "umap", split.by = "orig.ident", label = TRUE)
```

# 3.8 Finding differentialy expressed features
We are trying to find markers that define clusters via differential expression. You can find markers for a single cluster with the function `FindMarkers` or for all clusters with `FindAllMarkers`

```{r}
#Find markers 
ctl_d.integrated.markers <- FindAllMarkers(ctl_d.integrated, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE)
ctl_d.integrated.markers %>% group_by(cluster) %>% slice_max(n = 5, order_by = avg_log2FC)
```
Once the markers of each cluster are explained with the help of the previous code we now try to visualize our results. Here, we visualize the genes differently expressed in cluster 3: 

After we generates an expression heatmap. In this case, we are plotting the top 5 markers (or all markers if less than 5) for each cluster.

```{r}
# Plot
# VlnPlot(ctl_d.integrated, features = ("Ttn"))
FeaturePlot(ctl_d.integrated, features = c("Ttn"))
FeaturePlot(ctl_d.integrated, features = c("Myh1", "Myh2", "Myh10", "Myh9"))
# Features Plot for cluster identification 
# FeaturePlot(ctl_d.integrated, features = c("Myh7"))
# Heatmap 
ctl_d.integrated.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC) -> top5
DoHeatmap(ctl_d.integrated, features = top5$gene) + NoLegend() 
```

# Facultative Step: Assign cell type to each cluster 
_Wip in Progress_ 

```{r}
# UMAP 
# Integrated
# DimPlot(ctl_d.integrated, reduction = "umap", label = TRUE)
# Ctl
DimPlot(ctl.rna, reduction = "umap", label = TRUE)
# KO
DimPlot(ko.rna, reduction = "umap", label = TRUE)
```

```{r}
# HEATMAP
# Integrated 
# Find markers 
ctl_d.integrated.markers <- FindAllMarkers(ctl_d.integrated, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE)
ctl_d.integrated.markers %>% group_by(cluster) %>% slice_max(n = 5, order_by = avg_log2FC)
ctl_d.integrated.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC) -> top3
DoHeatmap(ctl_d.integrated, features = top3$gene) + NoLegend() 
# Ctl
ctl.rna.markers <- FindAllMarkers(ctl.rna, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE)
ctl.rna.markers %>% group_by(cluster) %>% slice_max(n = 5, order_by = avg_log2FC)
ctl.rna.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC) -> top3
DoHeatmap(ctl.rna, features = top3$gene) + NoLegend() 
# KO
ko.rna.markers <- FindAllMarkers(ko.rna, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE)
ko.rna.markers %>% group_by(cluster) %>% slice_max(n = 5, order_by = avg_log2FC)
ko.rna.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC) -> top3
DoHeatmap(ko.rna, features = top3$gene) + NoLegend() 

# 0:TypeIIa(Pkrg3) 1:TypeIIa(Cd36) 2:TypeIIb(Xist) 3:TypeIIa(Abgl1) 4:TypeIIa(Cd36) 5:TypeIIb(Gm26917) 6:TypeIIb(Amd1) 7:TypeIIa(Ppara) 8:Abca8a, Plxdc2, Ebf1 9:MTJ 10:FAPs(Cacna1c, Dlc1, Ebf1) 11:NMJ(Etv5)
```

```{r}
#FEATURE PLOT 
# Integrated 
FeaturePlot(ctl_d.integrated, features = c("Myh7", "Myh2", "Myh1", "Myh4", "Pdgfra", "Pax7", "Mrc1", "Pecam1"))
# Ctl
FeaturePlot(ctl.rna, features = c("Myh11", "Myh2", "Myh1", "Myh4", "Pdgfra", "Pax7", "Mrc1", "Pecam1"))
# KO 
FeaturePlot(ko.rna, features = c("Myh7", "Myh2", "Myh1", "Myh4", "Pdgfra", "Pax7", "Mrc1", "Pecam1"))
```


```{r}
# Clustering 
# CTL
# ctl.rna.cluster <- c("TypeIIa (Cd36)", "TypeIIa (Ppara)", "TypeIIb (Amd1)", "TypeIIb (Gm26917)", "TypeIIb (Myhas)", "Faps (Dlc1)", "MTJ", "NMJ")
ctl.rna.cluster <- c("TypeIIa(Pkrg3)", "TypeIIa(Cd36)", "TypeIIb(Xist)", "TypeIIa(Abgl1)", "TypeIIa(Cd36)", "TypeIIb(Gm26917)", "TypeIIb(Amd1)", "TypeIIa(Ppara)", "Abca8a, Plxdc2, Ebf1", "MTJ", "FAPs(Cacna1c, Dlc1, Ebf1)", "NMJ(Etv5)")
names(ctl.rna.cluster) <- levels(ctl.rna)
ctl.rna <- RenameIdents(ctl.rna, ctl.rna.cluster)
DimPlot(ctl.rna, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
# KO 
# ko.rna.cluster <- c("? (Dlc1)", "TypeIIb (Gm26917)", "TypeIIa (Cd36)", "TypeIIa (Ppara)", "D", "MTJ", "NMJ")
# names(ko.rna.cluster) <- levels(ko.rna)
# ko.rna <- RenameIdents(ko.rna, ko.rna.cluster)
# DimPlot(ko.rna, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend())
```


# 3.9 Clustree
Allows you to see how the number of clusters increases with the resolution. 

```{r}
head(ctl_d.integrated@meta.data)
clustree(ctl_d.integrated, prefix = 'integrated_snn_res.')
```

## 3. Multi-Omics: SnRNA-Seq & ATAC-Seq 
This part of the code allows a WNN analysis of a 10X Multiome RNA+ATAC dataset.

# 4. Muliomics Analysis: snRNA-Seq & ATAC-Seq 
# 4.1 Load data 

```{r}
# TODO: Do a for loop for load each dataset set instead of the duplication of the code 
# Load file  
x.inputdata.10x <- Read10X_h5(here("data","Ctl-D", "for_SIGNAC", "filtered_feature_bc_matrix.h5")) 
y.inputdata.10x <- Read10X_h5(here("data","D", "for_SIGNAC", "filtered_feature_bc_matrix.h5")) 
# Extract RNA and ATAC data
x.rna <- x.inputdata.10x$`Gene Expression`
x.atac <- x.inputdata.10x$Peaks
y.rna <- y.inputdata.10x$`Gene Expression`
y.atac <- y.inputdata.10x$Peaks
# Create Seurat object with only snRNA data 
x.multi <- CreateSeuratObject(counts = x.rna)
x.multi[["percent.mt"]] <- PercentageFeatureSet(x.multi, pattern = "^mt-")
y.multi <- CreateSeuratObject(counts = y.rna)
y.multi[["percent.mt"]] <- PercentageFeatureSet(y.multi, pattern = "^mt-")
# Adding ATAC-seq data
# set x 
grange.counts <- StringToGRanges(rownames(x.atac), sep = c(":", "-"))
grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts)
x.atac <- x.atac[as.vector(grange.use), ]
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79) 
seqlevelsStyle(annotations) <- 'UCSC'
genome(annotations) <- "mm10" 
# Don't forget to change this part, if there is an issue with this part try the following bash script : gzip -d atac_fragments.tsv.gz | bgzip | tabix -p bed
frag.file <- here("data","Ctl-D", "for_SIGNAC", "atac_fragments.tsv.gz")
chrom_assay <- CreateChromatinAssay(counts = x.atac, sep = c(":", "-"), genome = 'mm10', fragments = frag.file, min.cells = 10, annotation = annotations)
x.multi[["ATAC"]] <- chrom_assay
# set y 
grange.counts <- StringToGRanges(rownames(y.atac), sep = c(":", "-"))
grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts)
y.atac <- y.atac[as.vector(grange.use), ]
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79) 
seqlevelsStyle(annotations) <- 'UCSC'
genome(annotations) <- "mm10" 
frag.file <- here("data","D", "for_SIGNAC", "atac_fragments.tsv.gz") # Don't forget to change this part
chrom_assay <- CreateChromatinAssay(counts = y.atac, sep = c(":", "-"), genome = 'mm10', fragments = frag.file, min.cells = 10, annotation = annotations)
y.multi[["ATAC"]] <- chrom_assay
```

# Quick Analysis 

```{r}
x.multi <- wnn_analysis(x.multi)
```

```{r}
y.multi <- wnn_analysis(y.multi)
```

```{r}
# Trimming 
  x.multi <- subset(x = x.multi, 
                             subset = nCount_ATAC < 7e4 & nCount_ATAC > 5e3 & nCount_RNA < 25000 & nCount_RNA > 1000 & percent.mt < 20)
  # Normalization 
  DefaultAssay(x.multi) <- "RNA"
  x.multi <- SCTransform(x.multi, verbose = FALSE) %>% RunPCA() %>% RunUMAP(dims = 1:50, reduction.name = 'umap.rna', reduction.key = 'rnaUMAP_')
```

# 4.4 ATAC-Seq 
In a ATAC-Seq analysis with exclude the first dimension. Indeed, it is typically correlated with sequencing depth. 

```{r}
# We exclude the first dimension as this is typically correlated with sequencing depth
DefaultAssay(x.multi) <- "ATAC"
x.multi <- RunTFIDF(x.multi)
x.multi <- FindTopFeatures(x.multi, min.cutoff = 'q0')
x.multi <- RunSVD(x.multi)
x.multi <- RunUMAP(x.multi, reduction = 'lsi', dims = 2:50, reduction.name = "umap.atac", reduction.key = "atacUMAP_")
```

# 4.5 WNN Graph 
A WNN graph represent a weighted combination of RNA and ATAC-seq modalites.

```{r}
plan("multiprocess", workers = 4) # Parallelization on 4 cores 
x.multi <- FindMultiModalNeighbors(x.multi, reduction.list = list("pca", "lsi"), dims.list = list(1:50, 2:50))
x.multi <- RunUMAP(x.multi, nn.name = "weighted.nn", reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
resolution.range <- seq(from = 0, to = 1, by = 0.2)
x.multi <- FindClusters(x.multi, graph.name = "wsnn", algorithm = 3, verbose = FALSE, resolution = resolution.range)
```

# 4.6 Visualisation 

```{r}
umap.snrna <- DimPlot(x.multi, reduction = "umap.rna", label = TRUE) + ggtitle("RNA")
umap.atac <- DimPlot(x.multi, reduction = "umap.atac", label = TRUE) + ggtitle("ATAC")
umap.wnn <- DimPlot(x.multi, reduction = "wnn.umap", label = TRUE) + ggtitle("WNN")
umap.snrna
umap.atac
umap.wnn
# head(x.multi@meta.data)
clustree(x.multi, prefix = 'wsnn_res.')
```

# Other 

```{r}
FeaturePlot(x.multi, features = c("rna_Myh4", "rna_Myh1", "rna_Myh2", "Myh7", "rna_Pax7", "rna_Col22a1"), reduction = 'wnn.umap', max.cutoff = 10, ncol = 3)
FeaturePlot(x.multi, features = c("rna_Xist", "rna_Etv5", "rna_Gm26917", "rna_Dlc1"), reduction = 'wnn.umap', max.cutoff = 10, ncol = 3)
```

# Appendices 1: Export the data for more analysis 

```{r}
# Export the data at the .csv format 
ctl_d.matrix <-matrix(ctl_d.integrated@assays[["integrated"]]@var.features)
# y.rna.matrix <-matrix(y.rna@assays[["SCT"]]@var.features)
write.matrix(ctl_d.matrix,file="all_genes_ctl_d.csv")
# write.matrix(y.rna.matrix,file="D_data.csv")
```

# Appendices 2: Save the data 

```{r}
saveRDS(input_data, file = "../output/name_of_your_file.rds")
```
