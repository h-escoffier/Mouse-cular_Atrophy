---
title: "Mouse-scular Atrophy"
author: "Hugues Escoffier"
date: "2023-01-17"
output:
  pdf_document: default
  html_document: default
---

TODO: Find a way to directly attribute cluster to a type of cell based on literature data. (`Python` ?) 
      Parallelization : https://satijalab.org/seurat/articles/future_vignette.html

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Install libraries 
library(Seurat)
library(Signac) 
library(clustree)
# Additional 
library(patchwork)
library(dplyr)
library(ggplot2)
library(here)
library(MASS)
library(future)
# Genome 
# library(EnsDb.Mmusculus.v79) # Issue Related to R version  
```

# Functions

```{r}
# 
plot_trimming <- function(x) {
  # Plots 
  VnPlot <- VlnPlot(x, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
  RNAcount_MTPer <- FeatureScatter(x, feature1 = "nCount_RNA", feature2 = "percent.mt")
  RNAcount_RNAFeat <- FeatureScatter(x, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
  # Visualise 
  print(VnPlot)
  print(RNAcount_MTPer + RNAcount_RNAFeat)
}

# Update the automatization for a merge dataset 

# Normalisation, scaling, PCA & Dim 
first_automatisation <- function(input_data){
  # Normalisation with SCTransfrom
  # input_data <- SCTransform(input_data, vst.flavor = "v2", verbose = FALSE)
  # Scaling
  input_data <- FindVariableFeatures(input_data, selection.method = "vst", nfeatures = 2000)
  all.genes <- rownames(input_data)
  input_data <- ScaleData(input_data, features = all.genes)
  # PCA + Plot
  input_data <- RunPCA(input_data, npcs=50, features = VariableFeatures(object = input_data), verbose = FALSE)
  print(DimPlot(input_data, reduction = "pca"))
  # Elbow Plot 
  print(ElbowPlot(input_data, ndims = 50))
  return(input_data)
}

# Cluster, UMAP, Markers & Heatmap 
second_automatisation <- function(input_data, dimensionality) {  # rework this function for integrated data 
  # Clustering
  input_data <- FindNeighbors(input_data, reduction = "pca", dims = 1:dimensionality, verbose = FALSE)
  input_data <- FindClusters(input_data, resolution = 0.5, verbose = FALSE)
  input_data <- RunUMAP(input_data, dims = 1:dimensionality)
  DefaultAssay(input_data) <- 'RNA'
  #Plot
  print(DimPlot(input_data, reduction = "umap"))
  input_data.markers <- FindAllMarkers(input_data, min.pct = 0.25, logfc.threshold = 0.5, only.pos = TRUE) # Verify the treshord 
  input_data.markers %>% group_by(cluster) %>% slice_max(n = 2, order_by = avg_log2FC)
  print(input_data.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_log2FC) -> top2)
  # print(DoHeatmap(input_data, features = top2$gene) + NoLegend())
  return(input_data)
}
```

## Analysis of SnRNA-Seq & ATAC-Seq 

# 1. Data 
In this part we will use Ctl-D data and D (see readme in the 'data' folder for more information) 

```{r}
# Load the data for SnRNA-Seq Analysis
# x correspond to control data, y correspond to D(enervated) data
x.data <- Read10X(data.dir = here("data","Ctl-D", "for_SEURAT", "filtered_feature_bc_matrix"))
y.data <- Read10X(data.dir = here("data","D", "for_SEURAT", "filtered_feature_bc_matrix"))
# Initialize the Seurat object with non-normalized data.
x.rna <- x.data$`Gene Expression`
x.atac <- x.data$Peaks
y.rna <- y.data$`Gene Expression`
y.atac <- y.data$Peaks
# Create a Seurat Object + Add the mitochondrial information
x.rna <- CreateSeuratObject(counts = x.rna, project = "Ctl-D", min.cells = 3, min.features = 200)
x.rna[["percent.mt"]] <- PercentageFeatureSet(x.rna, pattern = "^mt-")
y.rna <- CreateSeuratObject(counts = y.rna, project = "D", min.cells = 3, min.features = 200)
y.rna[["percent.mt"]] <- PercentageFeatureSet(y.rna, pattern = "^mt-")
```

# 2. Merging two dataset 

```{r}
ctl_d.combined <- merge(x = x.rna, y = y.rna, add.cell.ids = c("CTL", "D"), project = "Ctl_D_Analysis")
# Plot the number of nuclei
table(ctl_d.combined$orig.ident)
# Split the data into a list 
ctl_d.list <- SplitObject(object = ctl_d.combined, split.by = "orig.ident")
```

# 2. scRNA-Seq
## 2.1. Trimming 

/!\ TODO : Remove the doublet with DoubletFinder

The filters applied are : 
  - 200 > Feature counts > 2,500
  - Mitochondrial counts < 0.8% 
  
```{r}
for (i in 1:length(x = ctl_d.list)) {
  # Visualization before trimming
  plot_trimming(ctl_d.list[[i]])
  # Trimming 
  ctl_d.list[[i]] <- subset(ctl_d.list[[i]], subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 0.8)
  # Visualization after trimming 
  plot_trimming(ctl_d.list[[i]])
  }
```

# 2.2 Normalisation
Data normalization can be achieved in several ways: 
- NormalizeData: 
  - LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor.
  - CLR: Centered log ratio transformation 
  - RC: Relative counts, feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor.
- SCTransform: 
  _Wip in Progress_ 

SCTransform Installation : https://satijalab.org/seurat/articles/sctransform_v2_vignette.html 

```{r}
# NormalizeData 
for (i in 1:length(x = ctl_d.list)) {
  ctl_d.list[[i]] <- NormalizeData(ctl_d.list[[i]], normalization.method = "LogNormalize", scale.factor = 10000)
  # Calculate a subset of features that exhibit high cell-to-cell variation in the dataset 
  ctl_d.list[[i]] <- FindVariableFeatures(ctl_d.list[[i]], selection.method = "vst", nfeatures = 2000)
  }
```

```{r}
# SCTransform
ctl_d.list <- lapply( X = ctl_d.list, FUN = SCTransform)
features <- SelectIntegrationFeatures(object.list = ctl_d.list, nfeatures = 5000)
ctl_d.list <- PrepSCTIntegration(object.list = ctl_d.list, anchor.features = features)
```

# 2.3 Integration 
_Work in Progress_

```{r}
# Integration with NormaliseData()
ctl_d.combined.anchors <- FindIntegrationAnchors(object.list = ctl_d.list, dims = 1:30)
ctl_d.integrated <- IntegrateData(anchorset = ctl_d.combined.anchors, dims = 1:30)
DefaultAssay(ctl_d.integrated) <- "integrated"
```

```{r}
# Integration with SCTransform()
ctl_d.combined.anchors <- FindIntegrationAnchors(object.list = ctl_d.list, normalization.method = 'SCT', anchor.features = features)
ctl_d.integrated <- IntegrateData(anchorset = ctl_d.combined.anchors, normalization.method = 'SCT')
```

# 2.4 Scaling 
We apply a linear transformation also call ‘scaling’. It is a pre-processing step to dimensional reduction techniques as PCA.

```{r}
all.genes <- rownames(ctl_d.integrated)
ctl_d.integrated <- ScaleData(ctl_d.integrated, features = all.genes)
```

We then perform a PCA on the scaled data. 

```{r}
ctl_d.integrated <- RunPCA(ctl_d.integrated, npcs=50, features = VariableFeatures(object = ctl_d.integrated), verbose = FALSE)
print(ctl_d.integrated[["pca"]], dims = 1:5, nfeatures = 5)
DimPlot(ctl_d.integrated, reduction = "pca")
```

# 2.5 Dimensionality 
The JackStraw procedure help to overcome the technical noise present in scRNA-seq data and identify the number of principal components to include in the analysis. This approach can lead to a robust compression of the dataset and improve the accuracy of the analysis.

Another alternative is to realise an Elbow plot. 

```{r}
# JackStraw Procedure
# ctl_d.integrated <- JackStraw(ctl_d.integrated, num.replicate = 100)
# ctl_d.integrated <- ScoreJackStraw(ctl_d.integrated, dims = 1:20)
# Plot
# JackStrawPlot(ctl_d.integrated, dims = 1:20)
# Elbow Plot
ElbowPlot(ctl_d.integrated, ndims = 50)
```

Interpretation of the result : 

# 2.6 Cluster the cells 
We applies a graph-based clustering approach, building upon initial strategies in Macosko et al. Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. 

We first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the `FindNeighbors()` function, and takes as input the defined dimensionality of the dataset. (cf. 2.4)

The `FindClusters()` function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. The authors of XXX package find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. 

```{r}
#Input the dimesionality of the dataset find at the 2.4 section 
ctl_d.integrated.data_set.dim = 14

ctl_d.integrated <- FindNeighbors(ctl_d.integrated, reduction = "pca", dims = 1:ctl_d.integrated.data_set.dim, verbose = FALSE)
# Select a range of resolution for Clustree 
resolution.range <- seq(from = 0, to = 1, by = 0.2)
ctl_d.integrated <- FindClusters(object = ctl_d.integrated, resolution = resolution.range)
# ctl_d.integrated <- FindClusters(ctl_d.integrated, resolution = 0.4, verbose = FALSE)
```

# Facultative Step : Create a subset 
In order to analyse only some part of you data you can create a subset according to some carasteristics. 

Source : 
  - https://satijalab.org/seurat/articles/essential_commands.html 
  - https://github.com/satijalab/seurat/issues/1890 

```{r}
# TODO: Find the values for each genes 
Idents(x.rna, WhichCells(object = x.rna, expression = Myh1 > 2 , slot = 'data')) <- 'Myh1'
Idents(x.rna, WhichCells(object = x.rna, expression = Myh2 > 3, slot = 'data')) <- 'Myh2'
genes <- FindMarkers(x.rna, ident.1 = 'Myh1', ident.2 = 'Myh2' )
print(genes)
```

# 2.7 Non-linear Dimensional Reduction 
_Wip in Progress_ 

```{r}
# 
ctl_d.integrated <- RunUMAP(ctl_d.integrated, dims = 1:ctl_d.integrated.data_set.dim, verbose = FALSE)  # ,umap.method = 'umap-learn', metric = "correlation"
# DefaultAssay(ctl_d.integrated) <- 'RNA' #### HeatMAP ?? 
#Plot
DimPlot(ctl_d.integrated, reduction = "umap")
DimPlot(object = ctl_d.integrated, reduction = "umap", group.by = "orig.ident", label = FALSE)
DimPlot(ctl_d.integrated, reduction = "umap", split.by = "orig.ident", label = TRUE)
```

# 2.8 Finding differentialy expressed features
We are trying to find markers that define clusters via differential expression. You can find markers for a single cluster with the function 'FindMarkers' or for all clusters with `FindAllMarkers`

```{r}
#Find markers 
ctl_d.integrated.markers <- FindAllMarkers(ctl_d.integrated, min.pct = 0.25, logfc.threshold = 0.25, only.pos = TRUE)
ctl_d.integrated.markers %>% group_by(cluster) %>% slice_max(n = 5, order_by = avg_log2FC)
```
Once the markers of each cluster are explained with the help of the previous code we now try to visualize our results. Here, we visualize the genes differently expressed in cluster 3: 

After we generates an expression heatmap. In this case, we are plotting the top 5 markers (or all markers if less than 5) for each cluster.

```{r}
# Plot
# VlnPlot(ctl_d.integrated, features = ("Ttn"))
FeaturePlot(ctl_d.integrated, features = c("Ttn"))
FeaturePlot(ctl_d.integrated, features = c("Myh1", "Myh2", "Myh10", "Myh9"))
# Features Plot for cluster identification 
# FeaturePlot(ctl_d.integrated, features = c("Myh7"))
# Heatmap 
ctl_d.integrated.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC) -> top5
DoHeatmap(ctl_d.integrated, features = top5$gene) + NoLegend() 
```

# 2.9 Clustree
_Wip in Progress_ 

```{r}
head(ctl_d.integrated@meta.data)
clustree(ctl_d.integrated, prefix = 'integrated_snn_res.')
```

# 3. ATAC-Seq 
_Wip in Progress_ 

# 3.1 Load data 

```{r}
# Load file  
inputdata.10x <- Read10X_h5(data.dir = here("data","Ctl-D", "for_SIGNAC", "filtered_feature_bc_matrix.h5")) 
# Extract RNA and ATAC data
x.rna <- inputdata.10x$`Gene Expression`
x.atac <- inputdata.10x$Peaks
# Create Seurat object with only snRNA data 
x.multi <- CreateSeuratObject(counts = x.rna)
x.multi[["percent.mt"]] <- PercentageFeatureSet(x.multi, pattern = "^mt-")
# Adding ATAC-seq data
grange.counts <- StringToGRanges(rownames(x.atac), sep = c(":", "-"))
grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts)
x.atac <- x.atac[as.vector(grange.use), ]
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79)
seqlevelsStyle(annotations) <- 'UCSC'
genome(annotations) <- "mm10"

frag.file <- "../data/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz"
chrom_assay <- CreateChromatinAssay(
   counts = atac_counts,
   sep = c(":", "-"),
   genome = 'hg38',
   fragments = frag.file,
   min.cells = 10,
   annotation = annotations
 )
pbmc[["ATAC"]] <- chrom_assay
```


# Facultative Step: Assign cell type to each cluster 
_Wip in Progress_ 

```{r}
x.rna.cluster <- c("0", "FastIIa", "MN Myh4", "FastIIb", "FastIIb", "Fibro3", "FastIIa", "MN Myh4", "MT", "unknown", "unknown", "MN Myh4", "MuSC")
names(x.rna.cluster) <- levels(x.rna)
x.rna <- RenameIdents(x.rna, x.rna.cluster)
DimPlot(x.rna, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

# Appendices 1: Export the data for more analysis 

```{r}
# Export the data at the .csv format 
ctl_d.matrix <-matrix(ctl_d.integrated@assays[["integrated"]]@var.features)
# y.rna.matrix <-matrix(y.rna@assays[["SCT"]]@var.features)
write.matrix(ctl_d.matrix,file="all_genes_ctl_d.csv")
# write.matrix(y.rna.matrix,file="D_data.csv")
```

# Appendices 2: Save the data 

```{r}
saveRDS(input_data, file = "../output/name_of_your_file.rds")
```
